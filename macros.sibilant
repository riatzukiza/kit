(namespace kit )
(include "./inc/macros")
(macro def-curried (name args ...body)
       `(var @name (R.curry (=> @args ...@body))))
(meta
 (def transpile.string (node)
   (pipe node.token
         (.replace (regex "(\\r\\n|\\n|\\r)" 'gm) "\\n\"+\"")))

(macro transpile-name (name) `(get (sibilant (get (first (get @name "contents")) 'token)) 'js))

(macro describe (name ...body)
       `(mixin (lit ...@body) @name))

(macro def-lit-macro (name args ...body)

       (assign name (transpile-name `(@ name)))

       (var t (pipe  `(lambda @args ...@body)
                     transpile
                     output-formatter))

       (set lit-macros name (eval t))

       null)
(macro lit (...body) `(literal ...@(.map body global.lit-macros )))

(def global.lit-macros (el)


  (if (expression? el)

      (do (var name (transpile-name el))

          (if (and (literal? (first el.contents))
                   (has-key? lit-macros name))

              ((get lit-macros name) (dots (rest (content-of el))))

              `(property ...@(content-of el)))) el))

(def lit-macros.init (args ...body)
  `(init @args ...@body))

(def lit-macros.gett (name ...body)
  `(gett @name ...@body))

(def lit-macros.alias (name from)
  `(alias @name @from))

(def lit-macros.sett (name value-name ...body)
  `(sett @name @value-name ...@body))



 )

(def-lit-macro gmth (name args ...body)
  `(generic @name (mth) @args ...@body))
(def-lit-macro mth (name args ...body)
  `(mth @name @args ...@body))

(def-lit-macro def (name args ...body)
  `(mth @name @args ...@body))

(macro def-generic (name args ...body)
       `(generic @name (def) @args ...@body))
(def-lit-macro def-generic (name args ...body)
  `(gmth @name @args ...@body))


(def-lit-macro gett (...body)
  `(gett ...@body))

(def-lit-macro sett (...body)
  `(sett ...@body))
(macro dotted? (token) `(= (get @token "type") "dots"))
(macro def-description (name args ...body)
       "define a type and describe it in a function like syntax. The arguements body is passed to the last instance of the init macro as its argument body."

       (def init-expression? (e) (and (expression? e) (= (get (first e.contents) 'token)  'init)))
       (def describer? (e) (not (init-expression? e)))

       (var init-form (pipe body (.filter  init-expression?)
                            last
                            ))
       (var init-body (ternary init-form (rest init-form.contents) []))

       (var description [ `(init @args ...@init-body)...(pipe body (.filter  describer?))])

       (if (dotted? name)
           `(set Descriptions (quote @name) (mixin (lit ...@description) @name  ))
           `(set Descriptions (quote @name) (mixin (lit ...@description) @name  ))))

(macro chain-promise (p ...rest)
       (if (empty? rest)
           p
           `(then-do @p (chain-promise ...@rest))))
