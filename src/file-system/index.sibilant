(include "../../inc/macros")
(import-namespace kit)
(const Path (require "path"))
(const fs (require "fs"))
(const join Path.join)

;;(const (literal scrape Dir Path types seconds minutes) (require "./deps"))
(const (literal create extend mixin) (require "../util"))
(def mix (types target)
  (mixin target types))

;;(const Event (require "common/util/event"))
;;(const adapt (require "common/collection/intrusive/adapter"))

;;(type Evented (mth init () (assign this.event ((adapt Event) this))))


;; A library I've not finished yet for working with http requests.

;;(macro has (object property (default predicate `defined?)) `(@predicate (get @object (quote @property))))

;;(comment (has key object function?))


(macro functorals (...bodys)
       (map-content body `(functorial ...@content)))

(macro recursive-functorial (name args obj value ...body)
       `(functorial @name @args (functor @obj .each (@value) ...@body)))

(macro fluent (def name args ...body)
       `(@def @name @args ...@body this))


(macro bind-list (l f)
       `(functor @l .reduce (x)))


(macro getter (name args ...body)
       ["get " `(mth @name @args ...@body)])
(macro setter (name args ...body)
       ["set " `(mth @name @args ...@body)])
(macro after (name def args ...body)
       `(generic @name @def
                 (...@(content-of args)
                     (target this)
                     (@name (=> ((dots args))
                                ((get target (quote @name))
                                 (dots args)))))
                 (@name ...arguments)
                 ...@body))
(macro gmth (name args ...body)
       `(generic @name (mth) @args ...@body))


(macro emits (name def args)
       `(after @name @def @args
               (target.emit (quote @name))))

(macro map (o arg ...body)
       `(functor @o .map @arg ...@body))
(macro each (o arg ...body)
       `(functor @o .each @arg ...@body))
(macro reduce (o arg ...body)
       `(functor @o .reduce @arg ...@body))
(macro export (name)
       `(set exports (quote @name) @name))
(macro join (...args)
       `(Path.join ...@args))


(import-namespace defs)

(import-namespace js)
(const Future (require "../async"))

(const readdir (.lift Future.Array fs.readdir))
(import (cond conditional) "../fp")


(lift-from fs Future.Future
           mkdir read-file write-file
           stat unlink rmdir)

(macro error! (...message)
       `(throw (new Error (+ ...@message))))
(comment (error! "attempted to make a value that already exists"))

;;(const (literal Hashed-trie) (require "./../collection/hashed-trie"))







(include
 "./inode.sibilant"
 "./file.sibilant"
 "./directory.sibilant")
