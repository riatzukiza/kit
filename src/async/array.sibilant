(const (literal List) (require "../collection/list"))

(macro with-resolution-of (p args ...body)
       `(pipe (.resolve Promise)))
(def accumulate (result element key)
  (with-resolution-of (callback element key) (element)
                      (result.push element) result))
(let bind (R.curry List.bind))

(specify Future-array (extend Future-collection)
         ;; NOTE for the following two functions I would like
         ;; to figure a more generic method over arbitrary collection
         ;; types.
         ;; I can't series un ordered types. This means that these functions do not apply
         ;; to all collection types

         ;; create a promise for the resolution of a map over
         ;; a given collection

         (generics (mth)
                   (bind (callback promise)
                         "List bind for Future lists"
                         (pipe (.resolve Future-array promise )
                               (.then (bind callback _ []))))
                   (map-all-serial  (callback collection )
                                    "map over all elements of an array, enforcing order of execution"
                                    (.reduce-all Future-array collection accumulate []))

                   (map-serial  (callback promise )
                                "map over all elements of a future array, maintaining the order which they occured"
                                (.reduce Future-array accumulate [] promise))

                   ( resolve (value )
                             "specialized resolve for future arrays.
Will resolve a promise for an array, and resolve all values of that array."
                             ((create this)
                              (then (.resolve Promise value) a
                                    (Promise.all a))))
                   ( all  (array )
                          ((create Future-array)
                           (Promise.all array)))))
(assign exports.Array Future-array)
