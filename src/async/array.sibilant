(const (literal List) (require "../collection/list"))

(macro with-resolution-of (p args ...body)
       `(pipe (.resolve Promise)))
(def accumulate (result element key)
  (with-resolution-of (callback element key) (element)
                      (result.push element) result))
(let bind (R.curry List.bind))

(specify Future-array (extend Future-collection)
         ;; NOTE for the following two functions I would like
         ;; to figure a more generic method over arbitrary collection
         ;; types.
         ;; I can't series un ordered types. This means that these functions do not apply
         ;; to all collection types

         ;; create a promise for the resolution of a map over
         ;; a given collection

         )
(generics (def-method Future-array)
          (bind (callback promise)
                "List bind for Future lists"
                (pipe (.resolve Future-array promise )
                      (.then (bind callback _ []))))
          (map-all-serial  (callback collection )
                           "map over all elements of an array, enforcing order of execution"
                           (.reduce-all Future-array collection accumulate []))

          (map-serial  (callback promise )
                       "map over all elements of a future array, maintaining the order which they occured"
                       (.reduce Future-array accumulate [] promise))

          ( resolve (value )
                    "specialized resolve for future arrays.
Will resolve a promise for an array, and resolve all values of that array."
                    ((create this)
                     (then (.resolve Promise value) a
                           (Promise.all a))))
          ( all  (array )
                 ((create Future-array)
                  (Promise.all array))))
(assign exports.Array Future-array)
