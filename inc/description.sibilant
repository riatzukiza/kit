(meta

 (macro lit (...body) `(literal ...@(.map body global.lit-macros )))
 (macro describe (name ...body)
        `(mixin (lit ...@body) @name))

 (macro transpile-and-format (form)
        `(pipe  @form
                transpile
                output-formatter))
 (macro def-lit-macro (name args ...body)

        (assign name (transpile-name `(@ name)))

        (var t (transpile-and-format  `(lambda @args ...@body)))

        (set lit-macros name (eval t))

        null)

 (def global.lit-macros (el)


   (if (expression? el)

       (do (var name (transpile-name el))

           (if (and (literal? (first el.contents))
                    (has-key? lit-macros name))

               ((get lit-macros name) (dots (rest (content-of el))))

               `(property ...@(content-of el)))) el))

 (def lit-macros.init (args ...body)
   `(init @args ...@body))

 (def lit-macros.gett (name ...body)
   `(gett @name ...@body))

 (def lit-macros.alias (name from)
   `(alias @name @from))

 (def lit-macros.sett (name value-name ...body)
   `(sett @name @value-name ...@body)))

(macro def-description (name args ...body)
       "define a type and describe it in a function like syntax. The arguements body is passed to the last instance of the init macro as its argument body."

       (def init-expression? (e) (and (expression? e) (= (get (first e.contents) 'token)  'init)))
       (def describer? (e) (not (init-expression? e)))

       (var init-form (pipe body (.filter  init-expression?)
                            last
                            ))
       (var init-body (ternary init-form (rest init-form.contents) []))

       (var description [ `(init @args ...@init-body)...(pipe body (.filter  describer?))])

       (if (dotted? name)
           `(set Descriptions (quote @name) (mixin (lit ...@description) @name  ))
           `(set Descriptions (quote @name) (mixin (lit ...@description) @name  ))))
