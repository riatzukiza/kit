{"version":3,"sources":["index.sibilant","src/macros/misc.sibilant","src/helpers.sibilant","src/macros/lambda.sibilant","macros/defs.sibilant"],"names":[],"mappings":"AAEA;AAFA;AAIA,IAAU,QAAV,GC6GkC,OAAD,CD7GvB,UC6GuB,CD7GjC;AAAA,IAAqB,aAArB,GC6GkC,OAAD,CD7GZ,eC6GY,CD7GjC;AAAA,IAAqC,EAArC,GC6GkC,OAAD,CD7GI,IC6GJ,CD7GjC;AAAA,IACW,QADX,GEuNmE,CDvG9B,OAAD,CD/Gf,gBC+Ge,CCuG+B,UFvNnE;AAAA,IAEU;AAAA,EAAmB,KAAV,CAAgB,GAAzB;AAAA,EAFV,GCgHqC,OAAD,CD9GK,aC8GL,CDhHpC;AAAA,oBCgHqC,OAAD,CD7GE,eC6GF,CDhHpC;AAAA,IAGW,MAHX,GEuNmE,oBFvNnE;AAAA,IAGkB,MAHlB,GEuNmE,oBFvNnE;AAAA,IAGyB,KAHzB,GEuNmE,mBFvNnE;AAAA,IAG+B,KAH/B,GEuNmE,mBFvNnE;AAAA;AAAA,IAIU,OAJV,GCgHqC,OAAD,CD5GlB,WC4GkB,CDhHpC;AAAA,IAKU,CALV,GCgHqC,OAAD,CD3GxB,OC2GwB,CDhHpC,CAJA;AAWK,oBAAL,GGiKwB,gCHjKG,CGiKH;AAAA;AAAA;AAAA,EHhKX,IAAX,CAAE,OAAF,CAAgB,CAAhB,CGgKsB;AAAA,SH/JtB,IG+JsB;AAAA,EHjKxB,CAXA;AAeA,IAAK,IAAL,GG8JqB,gBH9JV,GG8JU;AAAA;AAAA;AAAA,SH9JG,GAAR,CAAE,KAAF,CAAY,GAAZ,CG8JK;AAAA,EH9JrB,CAfA;AAgBM,OACA,CAAE,KAAF,CAAQ,sBAAR,CACA,CAAE,MAAF,CAAS,yBAAT,CACA,CAAE,MAAF,CAAS,oBAAT,EAA8B,EAA9B,CAHN,CAIQ,KAJR,CAIc,YAJd,CAhBA;AA2BA,IAAK,UAAL,GGkJqB;AAAA;AAAA;AAAA;AAAA,EHlJrB,CA3BA;AA6BA,IAAK,gBAAL,GGgJqB;AAAA;AAAA;AAAA;AAAA,EHhJrB,CA7BA;AA8BA,IAAK,aAAL,GG+IqB,yBH/IC,CG+ID,EH/IG,IG+IH;AAAA;AAAA;AAAA,SH9IlB,SAAD,CAAW,CAAI,CAAJ,IAAO,YAAD,CAAc,IAAd,CAAN,CAAX,EAAsC,CAAI,aAAD,CAAe,IAAf,EAAoB,WAApB,CAAH,GAAoC,KAApC,CAAtC,CG8ImB;AAAA,EH/IrB,CA9BA;AIkGkC,GJlElC,CAAK,gBAAL,GAAwB,OAhCxB;AAkCA,IAAK,cAAL,GG2IqB,0BH3IC,CG2ID;AAAA;AAAA;AAAA,SH3II,EAAC,CAAD,EG2IJ;AAAA,EH3IrB,CAlCA;AAqCA,IAAK,gBAAL,GGwIqB,4BHxII,KGwIJ,EHxIU,OGwIV;AAAA;AAAA;AAAA,SHvIF,GAAjB,CAAE,YAAF,CAAuB,GAAD,CAAK,CAAL,EAAO,kBAAP,CAAtB,EAAkD,KAAlD,CGuImB;AAAA,EHxIrB","sourcesContent":["(include \"./macros/macros\")\n(import-namespace kit)\n(source-mapping-url \"./index.sibilant\")\n\n(require! \"chokidar\" \"child_process\" \"fs\"\n          {Sibilant} \"./lib/sibilant\"\n          (literal (property Array Arr)) \"./lib/async\"\n          {create extend mixin curry} \"./lib/util.js\"\n          program \"commander\"\n          R \"ramda\" )\n\n(def Array.prototype.each (f)\n  (.for-each this f)\n  this)\n\n(def list (val) (.split val \",\") )\n(pipe program\n      (.usage \"[options] <file ...>\")\n      (.option \"-w --watch [watch-root]\")\n      (.option \"-o --output [path]\" [])\n      (.parse process.argv))\n\n(macro err-back (args emitter ...body)\n       `(=> (err ...@(content-of args))\n           (if err (.emit @emitter \"error\" err)\n               (do ...@body))))\n;; need a script to compile entire sibilant directories to js easily.\n(def make-pretty ())\n\n(def compile-to-same-dir ())\n(def get-target-name (o path)\n  (Path.join (or o (Path.dirname path)) (+ (Path.basename path \".sibilant\") \".js\")))\n(let build-with-options program)\n\n(def singleton-array (a) [a])\n\n\n(def compile-from-array (array options)\n  (.map-all-serial Arr  (nth 2 Sibilant.transpile ) array))\n",null,null,null,"(import-namespace core)\n(namespace kit)\n\n\n;; Creates a string that starts and ends with \\\"\n(docs \"creates a string that starts and ends with '\\\"'\")\n(macro wrap-in-quotes (...str) `(+ \"\\\"\" ...@str \"\\\"\"))\n\n;; I don't know if I actually use this one any where.\n\n;; Create a function that is exported as a part of the current module.\n(macro public (name args ...rest) `(var @name (set exports (quote @name) (# @args ...@rest))))\n\n\n;; es6 style ... operator\n(macro dots (...contents) [\"...\" contents])\n\n;; don't like these\n(alias-macro dots spread-op)\n(alias-macro dots rest-param)\n\n;;(macro &spread (x) [\"...\" x])\n\n;;(macro &rest (x) [\"...\" x])\n\n;;(macro const ( ...pairs))\n\n\n\n;; Utility for creating promises\n(macro make-promise (...body)\n       `(new Promise (=> (success fail)\n                         (var resolve success\n                              reject fail)\n                         ...@body)))\n\n;; add one to a variable\n;;(macro increment (n) `(assign @n (+ 1 @n)))\n;;(alias-macro increment ++)\n\n;; remove one from a variable\n(macro decrement (n) `(assign @n (- 1 @n)))\n(alias-macro increment --)\n\n;; Define a lambda that returns a promise.\n(macro promised (args ...body) `(=> @args (make-promise ...@body)))\n(alias-macro promised -->)\n\n\n(macro not-implemented (args ) `(# @args (throw (new Error \"not implemented\"))))\n\n(macro >> (f ...args) `(.bind @f this ...@args))\n\n(macro += (handle value) [handle \" += \" value])\n\n;; Define a lambda that returns \"this\"\n(macro fluent (args ...body) `(# @args ...@body this))\n\n;;(var module (ternary (not module) {exports {}} module))\n;;(var exports module.exports)\n\n\n;; helper for itteration.\n(macro for-each (item of collection ...body) `(.for-each @collection (=> @item ...body)) )\n\n\n(macro do-block (...body) (indent (apply ^do body)))\n\n\n(namespace kit)\n;;(comment ////////////////////////////////////////////////////////////////////////////////////////)\n(macro cons (left right ...rest)\n       [left [right (cons ..rest)]])\n;;get list contents\n(macro mac-sym-con (sym)\n       `(get @sym \"contents\"))\n(alias-macro mac-sym-con content-of)\n\n\n\n;;(comment Assignments/////////////////////////////////////////////////////////////////////////////)\n\n(macro this! (name) `(set this (quote @name) @name ))\n\n(macro assignment (type name value) [ type \" \" name \" = \" value ])\n\n\n(macro const (...rest) `(assignment const ...@rest))\n\n(macro consts ( ...pairs)\n       (as-statement\n        [ \"const \" (pipe pairs\n\n                         destructure\n\n                         (.map (lambda (pair)  [(first pair) \" = \" (second pair)]))\n\n                         (interleave \",\\n    \")) ]))\n(macro let (...rest) `(assignment let ...@rest))\n;;(comment \"////////////////////////////////////////////////////////////////////////////////////////\")\n\n(macro comma (...opts)\n       (interleave \",\" opts))\n\n(macro comma-op (...stuffs) [\"( \" ...(interleave \",\" stuffs) \" )\"])\n\n(macro statement (name params ...body)\n       [ name \"\" `(comma-op @(get params.contents)) \" {\\n\" (indent ...body) \"\\n}\\n\" ])\n\n;;Enclosing delimiters\n(macro parenthetic (...opts) [\"( \" (interleave \" \" opts) \" )\"])\n\n(macro curly (...rest) [ \"{ \" ...(indent ...rest) \" }\"])\n(macro square-bracket (...rest) [ \"[ \" ...(indent ...rest) \" ]\"])\n\n(macro block (...rest) `(curly ...@(interleave \"\\n\" rest) ))\n\n(macro state ( name params ...rest) [name `(parenthetic @params) `(block ...@rest)])\n\n;;Object litterals\n(macro method (name args ...body) `(state @name (comma ...@(mac-sym-con args)) (do-block ...@body)))\n(alias-macro method mth)\n(macro method! (name args ...body) `(state @name (comma ...@(mac-sym-con args)) ...@body))\n(alias-macro method! mth!)\n\n\n(macro property (name value) [name \":\" value])\n\n(macro literal (...opts) `(curly ...@(interleave \",\\n\" opts)))\n\n(macro loop (head ...body)\n       (if (empty? body)\n           head `(...@(content-of head)\n                     (loop @(first body) ...@(rest body)))))\n\n(macro for (itt-var condition increment ...body)\n       [\"for \" \"(\" itt-var \";\" condition \";\" increment \")\" \"{\\n\"\n       ...(interleave \";\\n\" body)\n       \"}\" ])\n(macro collect (name value ...body)\n       (print \"compling collection thing\")\n       `(scoped (let @name @value)\n                ...@body\n                @name)\n       )\n\n(macro type (name ...body)\n       (let type-name name)\n       (log-pretty \"defining type\" name)\n       (set namespace (output-formatter (transpile name))\n            (lambda (def-type name args)\n              (if (or name args)\n                  (do (if args null\n                          name (assign args name\n                                       name def-type\n                                       def-type `assign))\n\n                      `(@def-type @name ((create @type-name) ...@(content-of args))))\n\n                  (do (assign args def-type)\n                      `((create @type-name) ...@(content-of args))))))\n\n       `(const @name (literal (property symbol (Symbol (quote @name))) ...@body)))\n\n(macro set-macro (name args ...body)\n       `(set sibilant.macros.namespace (output-formatter (transpile @name))\n             (lambda @args ...@body)))\n(macro create-type (def-type type-name name args)\n       `(if (or name args)\n           (do (if args null\n                   name (assign args name\n                                name def-type\n                                def-type `assign))\n\n               `(@def-type @name ((create @type-name) ...@(content-of args))))\n\n           (do (assign args def-type) `((create @type-name) ...@(content-of args)))))\n\n(macro specify (name mod ...body)\n       (let type-name name)\n       (log-pretty \"defining type\" name)\n       (set namespace (output-formatter (transpile name))\n            (lambda (def-type name args)\n              (if (or name args)\n                  (do (if args null\n                          name (assign args name\n                                       name def-type\n                                       def-type `assign))\n\n                      `(@def-type @name ((create @type-name) ...@(content-of args))))\n\n                  (do (assign args def-type)\n                      `((create @type-name) ...@(content-of args))))))\n\n       `(const @name (...@(content-of mod)\n                         (literal (property symbol (Symbol (quote @name))) ...@body))))\n\n\n;;keywords\n(macro function (name args ...body) [\"function \" `(method! @name @args ...@body)])\n(macro fn (name args ...body) `(function @name @args (do-block ...@body)))\n\n(macro if! (cond ...body))\n(macro else-if! (cond ...body))\n(macro else! (...body))\n\n(macro cond! (condition body ...rest))\n\n(macro try! (...body)\n       (let last (.pop body))\n       [\"try \" `(block ...@body) last])\n(macro catch! (...body)\n       [\"catch(e) \" `(block ...@body)])\n\n;;(const (literal create mixin extend) (require \"common/util/funcs\"))\n\n\n\n(macro event (method emitter  event args ...body)\n       `(pipe  @emitter\n               (@method (quote @event) (=> @args ...@body))\n               (.once \"error\"\n\n                      (=> (err)\n                          (print \"error on\" (quote @event)\n                                 \"of\" (quote @emitter)\n                                 \"given\" (quote @args))\n                          (print err)))))\n\n(macro on (emitter event args ...body)\n       `(.on @emitter @event  (=> @args ...@body)))\n\n(macro once (emitter event args ...body)\n       `(event .once @emitter @event @args ...@body))\n\n\n(macro then (obj arg ...body)\n       `(functor @obj .then (@arg) ...@body))\n\n(macro sequence (start f ...body)\n       `(pipe @start\n              ...@(functor body .map (term)\n                           `(@f ...@(get term \"contents\")))))\n\n(macro configure (configs dir ...body)\n\n       `(functor @configs .map (c k)\n                 (sequence (.get-child @dir k) then ...@body)))\n\n(macro p-map (...body)\n       `(literal\n         ...@(functor body .map (prop)\n                      `(property @(first prop.contents)\n                                 @(second prop.contents)))))\n\n\n\n(macro export (value)\n       `(set module.exports (quote @value) @value))\n\n(macro map-content (expressions ...body)\n       `(functor @expressions .map ((literal content))\n                 ...@body))\n(macro functorial (def name args ...body)\n\n       `(@def @name (callback ...@ (content-of args)) ...@body))\n\n(macro set-for (target ...body)\n       (functor body .map (arg i)\n                (if (expression? arg)\n                    `(set @target  (quote @(first (content-of arg)))\n                          @(first (content-of arg)))\n                    `(set @target (quote @arg) @arg))))\n(macro init (args ...body)\n       `(generic init (mth)  @args\n                 (set-for this ...@(content-of args))\n                 ...@body\n                 this))\n\n\n;; A library I've not finished yet for working with http requests.\n\n;;(macro has (object property (default predicate `defined?)) `(@predicate (get @object (quote @property))))\n\n;;(comment (has key object function?))\n\n\n(macro functorals (...bodys)\n       (map-content body `(functorial ...@content)))\n\n(macro recursive-functorial (name args obj value ...body)\n       `(functorial @name @args (functor @obj .each (@value) ...@body)))\n\n(macro fluent (def name args ...body)\n       `(@def @name @args ...@body this))\n\n\n(macro bind-list (l f)\n       `(functor @l .reduce (x)))\n\n\n(macro getter (name args ...body)\n       [\"get \" `(mth @name @args ...@body)])\n(macro setter (name args ...body)\n       [\"set \" `(mth @name @args ...@body)])\n(macro after (name def args ...body)\n       `(generic @name @def\n                 (...@(content-of args)\n                     (target this)\n                     (@name (=> ((dots args))\n                                ((get target (quote @name))\n                                 (dots args)))))\n                 (@name ...arguments)\n                 ...@body))\n(macro gmth (name args ...body)\n       `(generic @name (mth) @args ...@body))\n\n\n(macro emits (name def args)\n       `(after @name @def @args\n               (target.emit (quote @name))))\n\n(macro each (o arg ...body)\n       `(functor @o .each @arg ...@body))\n(macro reduce (o arg ...body)\n       `(functor @o .reduce @arg ...@body))\n(macro export (name)\n       `(set exports (quote @name) @name))\n\n(macro map (value args ...body)\n       `(functor @value .map @args ...@body))\n\n(macro a-let (vars ...body)\n       `(then (.all Future.Object\n                    (p-map ...@ (map (content-of vars) ((literal contents ))\n                                     `(@ (first contents) @ (second contents)))))\n              (literal ...@ (map (content-of vars) ((literal contents))\n                                 (first contents)))\n\n\n              ...@body))\n(macro s-let! (vars ...body)\n       `(do ...@(map vars.contents ((literal contents))\n                 `(let @ (first contents) @ (second contents )))\n         ...@body))\n\n(macro lift (future-type name source)\n       `(const @name (.lift @future-type @source)))\n\n(macro lift-from (source future-type ...body)\n       `(const [...@body]\n               [...@(map  body (name)\n                          `(.lift @future-type (get @source (quote @name))))]))\n\n(macro then-thunk (p ...body) `(then @p nil ...@body))\n(alias-macro then-thunk #~)\n(alias-macro then-thunk then-do)\n\n\n(macro proxy (name property)\n       `(mth @name ((dots args))\n             ((get this (quote @property) (quote @name)) (dots args))))\n(macro catch (p ...body)\n       `(.catch @p (=> (e) ...@body)))\n\n(macro import (thing from)\n       `(const (literal ...@(content-of thing)) (require @from)))\n(macro route (method path ...body)\n       `(@method app @path\n                 (=> (req res)\n                     (lets (url (Url.parse req.url))\n\n                           ((literal path\n                                     query\n                                     hash port\n                                     search\n                                     pathname\n                                     auth\n                                     slashes\n                                     href\n                                     protocol\n                                     host) url))\n                     (def-promised write (v)\n                       (res.write v success)) ...@body)))\n"]}