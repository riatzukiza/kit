(const R (require "ramda"))
;;(var get-string (R.prop "string"))

;;(var is-dir-symbol (R.equals Directory.symbol))
;;(var symbol-of (R.prop "symbol"))
;;(var is-dir (R.pipe symbol-of is-dir-symbol))
(var traverse (R.invoker 1 "traverse"))
;;(var has (R.invoker 1 "has"))

;;(var find (curry (=> (list k) (.find list k))))
;;(var then (curry (=> (p f) (.then p f))))
;;(var get-child (curry (=> (children name) (children.get name))))
;;(var set-child (curry (=> (children name data) (children.set name data))))

(var value-of (R.prop "value"))
(var name-of (R.prop "name"))
(var same-symbol-as (R.eq-props "symbol" ))
;;(var value-is-same-type (=> (branch-type )))

(type Cache
      (init ( value branch-type leaf-type (children (new Map))))
      (generic has (mth) (name children)
               (.has children name))
      (generic get (mth) (k value children)
               (remember children k
                         (then (.find value k) sub-value
                               (let node ((create this) sub-value))
                               (.set children k node) node))) 
      (generic each (mth) ( f value )

               (comment
                (then-call-method this 'get name))

               ;;(let call-then (=> (name) (.then (this.get name) f) ))
               ;;(defer-call  (this.get name) 'then f)
               (each value (name)
                     (.then (.get this name) f) ))

      (generic filter-each (mth) (filter (callback (=> (x) x)) dir (node this))
               (.each node (cond filter callback) dir))

      (generic filtered-traverse (mth) ( filter (callback (=> (x) x)) dir (node this))
               (.each this (cond (R.pipe value-of name-of (same-symbol-as branch-type))
                                 (traverse callback) callback)))

      (generic traverse (mth) ( callback branch-type leaf-type)
               (.each this (cond (R.pipe value-of name-of (same-symbol-as branch-type))
                                 (traverse callback) callback))))


(macro remember (table value ...body)
       `(if (.has @table @value)
            (.get @table @value)
            (.set @table @value (do ...@body))))
(comment (let d ((create Cache) ((create Directory) ".") Directory File))
         (let ignored (R.either (R.equals ".git") (R.equals "node_modules")))
         (pipe d
               ;;(.filter-r (R.compose R.not ignored name-of value-of) (aprint "file thing?"))
               (.traverse  (aprint "dir"))
               (.catch  (aprint "failed to traverse"))))

(specify FS-cache (extend Cache)
         (property leaf-type File)
         (property branch-type Directory)
         (property create (R.pipe (create Directory)(create Cache))))
