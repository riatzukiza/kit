"use strict";
// Generated by LispyScript v1.0.0
var part = require("./partialApplication.js");
var curry = part.curry;
var logical = require("./logical.js");
var mapObject = function mapObject(a,f,self) {
    var b = {};
    (function(o,f,s) {
        var _k = Object.keys(o);
        return (_k).forEach(function(elem) {
            return f.call(s,o[elem],elem,o);
        });
    })(a,function(v,k,o) {
        b[k] = v;
    },self);
    return b;
}
var concatObject = function concatObject(a,b,self) {
    var c = {};
    (function(o,f,s) {
        var _k = Object.keys(o);
        return (_k).forEach(function(elem) {
            return f.call(s,o[elem],elem,o);
        });
    })(a,function(v,k,o) {
        c[k] = v;
    },self);
    (function(o,f,s) {
        var _k = Object.keys(o);
        return (_k).forEach(function(elem) {
            return f.call(s,o[elem],elem,o);
        });
    })(b,function(v,k,o) {
        c[k] = v;
    },self);
    return c;
}
var mergeObject = function mergeObject(a,b,self) {
    (function(o,f,s) {
        var _k = Object.keys(o);
        return (_k).forEach(function(elem) {
            return f.call(s,o[elem],elem,o);
        });
    })(b,function(v,k,o) {
        a[k] = v;
    },self);
    return a;
}
var extendObject = function extendObject(a,b,self) {
    return mergeObject(Object.create(a),b,self);
}
var defineFactory = part.curry(function defineFactory(Constructor,prototype) {
    Constructor.prototype = prototype;
    function factory(value,obj) {
        return new Constructor(value,obj);
    }
    factory.prototype = prototype;
    factory.constructor = Constructor;
    return factory;
});
var extendFactory = part.curry(function extendFactory(Constructor,factory,prototype) {
    var sub = defineFactory(Constructor,extendObject(factory.prototype,prototype));
    sub.super(factory.constructor);
    sub.superFactory = factory;
    return sub;
});
var Functor = part.curry(function Functor(mod,mapping,value) {
    value = mod(value);
    function functor(fn) {
        functor.value = mapping(fn,functor.value);
        return value;
    }
    functor.mod = mod;
    functor.mapping = mapping;
    functor.value = value;
    return functor;
});
function id(x) {
    return x;
}
var Identity = Functor(id);
var Maybe = Identity(function(fn,value) {
    console.log("maybe",fn,value);
    return (((!(typeof(value) === "undefined"))
             && (!(value === null)))
            ? fn(value)
            : null);
});
var ArrayMap = Identity(function(fn,value) {
    return value.map(fn);
});
var StringMap = Functor(function(value) {
    return value.split("");
},ArrayMap.mapping);
var Applicative = part.curry(function Applicative(type,value) {
    return Functor(type,function(fn,x) {
        return function(y) {
            return fn(x.value,y);
        };
    },value);
});
//bugged
/*
var Monad = part.curry(function Monad(type,value) {
    console.log("creating monad with value",value);
    console.log("creating monad with type",type);
    return Functor(type,function(fn,x) {
        console.log("monadic value",x);
        return x(fn);
    },value);
})
var lift = part.curry(function lift(monadicType,f) {
    return function(x) {
        console.log("lifted",f,x);
        return monadicType(f(x));
    };
})*/
function compose() {
    var args = [...arguments];
    return function(a) {
        return args.reduce((x,f) => f.call(this,x),a);
    };

}
var aprod = function aprod(a,b,self) {
    return a.map((x,k) => x.call(self,b[k]));
};
var oprod = function oprod(a,b,self) {
    return mapObject(a,(x,k) => x.call(self,b[k]) );
}
var hom = function hom(output,inputs,f) {
    var h = function() {
        return output.call(this,f.apply(this,aprod(inputs,arguments,this)));
    };
    h.inputs = inputs;
    h.outputs = output;
    h.func = f;
    return h;
};
function getProp(k,o) {
    return o[k];
}
//get props is undefined, things are getting moved.
//I should probably just include that here for the moment.
var adhochom = function() {
    var homs = [...arguments];
    var adhom = function() {
        var res = null;
        homs.some(logical.conditional(
            compose(curry(getProp)('inputs'),part.post(aprod,[arguments,this])),
            (h) => (res = h.output.call(this,h.func.apply(this,arguments)),true),
            () => false));
        return res;
    };
    adhom.extend = function(hom) {
        this.homs.push(hom);
    };
    adhom.homs = homs;
    return adhom;
};
hom.adhoc = adhochom;
module.exports = {
    getProp:getProp,
    compose:compose,
    hom:hom,
    product:{
        array:aprod,
        object:oprod,
    },
    merge:{
        objects:mergeObject,
    },
    concat:{
        objects:concatObject,
    },
    object:{
        merge:mergeObject,
        concat:concatObject,
        extend:extendObject,
        product:oprod,
        map:mapObject,
    },
    array:{
        product:aprod
    },
    Functor:Functor,
    Applicative:Applicative,
    Maybe:Maybe,
    Identity:Identity
}
