(include "./macros/macros")
(import-namespace kit)
(source-mapping-url "./compile.map")
(require "")

;; policies?
(def compile-kit ()
  (traverse  (node)
            (pipe node.file
                  ())))

(def compile-source-file (path dest)
  {
  src ()
  }
  (then-let ((src (fill-file path))
             (target (fill-file path)))))

(def compile-markdown ())
(def compile-browser-bundle ())
(def evaluate-source-file ())

(let system (create System))
(let s (system "./"))
(let src (.get "src"))
(let is-file (R.invoker "is-file" 0))
;; somthing important here is that the file systems structure after these maps will only be anologous if we exclude the extensions.
;; the extensions are *types*

;; This will create a tree of inodes that represent valid sibilant files.
;; if we created an array of inodes, we'd be able to manipulate them same as if they are in the tree?
;; they are whta contain the path data, no?
;; The trie is just an index.
(let source-tree (filter  is-sibilant-file src))
(let source-buffers (map buffer-of source-tree ))
