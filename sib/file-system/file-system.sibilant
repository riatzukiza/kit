

(def plift (f)
  (promised ((dots args))
            (.apply f this [ (dots args) (=> (err data) (if err (reject err) (resolve data))) ])))

(var stat (plift fs.stat)
     mkdir (plift fs.mkdir)
     read-file (plift fs.read-file)
     write-file (plift fs.write-file )
     readdir (plift fs.readdir))

(def fill-sub-dir ([p sub-path] seg) [ (catch (then-do p (mkdir sub-path))) (Path.join sub-path seg) ])


(var *directory? (=> (stats) (.is-directory stats)))

(var emit (R.invoker 2 "emit"))

(var bi-curry (R.curry-n 2 ))
(var _ R._)

;; (var *discover-type (cond (R.pipe R.head directory?)
;;                           (R.pipe (nth 1) (create Directory))
;;                           (R.pipe (nth 1) (create File))))
;; (var *discover-node (bi-curry (R.unapply (R.pipe (.set *tree seq) *discover-type) )))


(macro fpipe (...body)
       `(=> ($fpipe)
            (pipe $fpipe ...@body)))

(var not-single-dot (=> (token) (not (= token ".")))
     find-value (=> (seq *tree) (get (.find *tree seq) 'value))
     tokenize (fpipe  (.split  "/") (.filter  not-single-dot)))

;; Be you, the app that uses this app is the test for the app

(def-lit-macro def-curried (name args ...body)
  `(property @name (R.curry (lambda @args ...@body))))

(specify File-system (extend Event-emitter.prototype))

(describe File-system

          (root ".")

          (init (root (*tree ((create Tree-map) ))))

          (def-curried *discover-node  (path seq *tree  fs stats)
            (.set *tree seq
                  (if (.is-directory stats)
                      ( (create Directory) path fs)
                      ( (create File) path fs))))

          (def *find-absolute-path (path root)
            (Path.resolve  root path))

          (def-generic find
              (path

               [ *tree  root ]
               [ *discover-node *find-absolute-path ]

               ;; need to fix generic to let me do these inside of arrays.

               (rel-path (*find-absolute-path path root))

               (seq (tokenize rel-path ))
               (node (find-value seq *tree)) 

               (fs this))

            (if node
                (.resolve Promise node)
                (.then (stat rel-path)
                       (*discover-node rel-path seq *tree fs))))

          (def-generic watch
              (path
               [root]
               [ *find-absolute-path ]
               (rel-path (*find-absolute-path path root))
               (fs this))

            (async-let ((node (.find fs path [] [] rel-path)))

              (pipe chokidar
                    (.watch  node.path)
                    (on  'all (event-name changed-path stats)

                         (async-let ((changed-node (.find fs (Path.relative root changed-path ) )))

                           (.emit node event-name changed-node))))
              node))

          (def-generic insert (path [root ] [ *find-absolute-path ]
                                    ( type File )

                                    (rel-path (*find-absolute-path path root))
                                    (fs this))
            (catch (.find fs path)

              (let* ((seq (tokenize path))
                     (file-name (.pop seq)))

                (pipe seq
                      (.reduce  fill-sub-dir [(Promise.resolve) "./"])
                      first
                      (then-do (.set-value ((create type) path fs)  ))))))

          (def-generic set (path v ( type File ) (fs this))

            (async-let  ((node (.insert fs path [] [] type fs)))
              (.set-value node v)))
          (def-generic delete (path))
          (def-generic each (f))
          )
