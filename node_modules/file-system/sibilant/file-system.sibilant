(require! "fs" Path "path" "chokidar" (lit Event-emitter) "events")

(specify File (extend Event-emitter.prototype))

(describe File
          (init (path fs) (.call Event-emitter this))


          (gett value (read-file this.path))
          (sett value v (write-file this.path v))

          (def-generic get-value (path)
            (read-file path))

          (def-generic set-value ( (value "") path)
            (then-do (write-file  path value) this))

          ;; (gett bandwidth )
          ;; (gett latency )
          ;; (gett size )
          ;; (gett stats )

          ;; (gett creation-time )
          ;; (gett last-modified )
          ;; (gett permissions )
          ;; (gett owner )
          ;; (gett parent )


          (gett read-stream (.get-read-stream this))
          (gett write-stream (.get-write-stream this))

          (gmth get-read-stream (path) (fs.create-read-stream path))
          (gmth get-write-stream (path) (fs.create-write-stream path))


          (gmth write ())
          (gmth read ())
          (gmth pipe ()))

(specify Directory (extend Event-emitter.prototype))

(describe Directory
          (init (path fs) (.call Event-emitter this))

          (def-generic set-value ((value []) path)
            (if (array? value)
                (then-do (Promise.all (map value (k) (mkdir (Path.join path k)))) this)
                (mkdir (Path.join path value))))

          (def-generic get-value (path))

          (def-generic set (path value ( type File ) ))
          (def-generic insert (path ( type File ) ))

          (def-generic each (f))
          (def-generic map (f))


          (gett keys (readdir this.path))
          (gett children (pipe this.keys
                               (.map (=> (k) (Path.join this.path k))))))

(def-curried discover-node  (path seq *tree fs stats)
  (.set *tree seq
        (if (.is-directory stats)
            ( (create Directory) path )
            ( (create File) path))))


(specify File-system (extend Event-emitter.prototype))

(def plift (f)
  (promised ((dots args))
            (.apply f this [ (dots args) (=> (err data) (if err (reject err) (resolve data))) ])))

(var stat (plift fs.stat)
     mkdir (plift fs.mkdir)
     read-file (plift fs.read-file)
     write-file (plift fs.write-file )
     readdir (plift fs.readdir))

(def fill-sub-dir ([p sub-path] seg) [ (catch (then-do p (mkdir sub-path))) (Path.join sub-path seg) ])


(var *directory? (=> (stats) (.is-directory stats)))

(var bi-curry (R.curry-n 2 ))
(var _ R._)

;; (var *discover-type (cond (R.pipe R.head directory?)
;;                           (R.pipe (nth 1) (create Directory))
;;                           (R.pipe (nth 1) (create File))))
;; (var *discover-node (bi-curry (R.unapply (R.pipe (.set *tree seq) *discover-type) )))


(describe File-system
          (init (root (*tree ((create Tree-map) ))))

          (def-generic find (path
                             *tree
                             (seq (.filter (.split path "/") (=> (token) (not (= token ".")))))
                             (node (get (.find *tree seq) 'value))
                             (fs this))
            (if node
                (.resolve Promise node)
                (.then (stat path)
                       (discover-node path seq *tree fs))))

          (def-generic watch (path (fs this))
            (then (.find fs path) node
                  (on (.watch chokidar path) 'all (event-name path stats)
                      (then (.find fs (.relative Path fs.root path)) r
                            (.emit node event-name  r))) node))

          (def-generic insert (path ( type File ) (fs this))
            (catch (.find fs path)

              (let* ((seq (.split path "/"))
                     (file-name (.pop seq)))

                (then-do (first (.reduce seq fill-sub-dir [(Promise.resolve) "./"]))
                         (.set-value ((create type) path fs)  )))))

          (def-generic set (path v ( type File ) (fs this))

            (then (.insert fs path type fs) node (.set-value node v))))





