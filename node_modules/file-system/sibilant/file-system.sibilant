(require! "fs" Path "path" "chokidar" (lit Event-emitter) "events")

(include "./fs-node" "./file" "./directory")





(specify File-system (extend Event-emitter.prototype))

(def plift (f)
  (promised ((dots args))
            (.apply f this [ (dots args) (=> (err data) (if err (reject err) (resolve data))) ])))

(var stat (plift fs.stat)
     mkdir (plift fs.mkdir)
     read-file (plift fs.read-file)
     write-file (plift fs.write-file )
     readdir (plift fs.readdir))

(def fill-sub-dir ([p sub-path] seg) [ (catch (then-do p (mkdir sub-path))) (Path.join sub-path seg) ])


(var *directory? (=> (stats) (.is-directory stats)))

(var emit (R.invoker 3 "emit"))

(var bi-curry (R.curry-n 2 ))
(var _ R._)

;; (var *discover-type (cond (R.pipe R.head directory?)
;;                           (R.pipe (nth 1) (create Directory))
;;                           (R.pipe (nth 1) (create File))))
;; (var *discover-node (bi-curry (R.unapply (R.pipe (.set *tree seq) *discover-type) )))


(macro fpipe (...body)
       `(=> ($fpipe)
            (pipe $fpipe ...@body)))

(var not-single-dot (=> (token) (not (= token ".")))
     find-value (=> (seq *tree) (get (.find *tree seq) 'value))
     tokenize (fpipe  (.split  "/") (.filter  not-single-dot)))

;; Be you, the app that uses this app is the test for the app
(def-lit-macro def-curried (name args ...body)
  `(property @name (R.curry (lambda @args ...@body))))

(describe File-system

          (root ".")

          (init (root (*tree ((create Tree-map) ))))

          (def-curried *discover-node  (path seq *tree fs stats)
            (.set *tree seq
                  (if (.is-directory stats)
                      ( (create Directory) path )
                      ( (create File) path))))
          (def *find-absolute-path (path root)
            (Path.resolve (.join Path root path))
            )

          (def-generic find
              (path

               [ *tree  root ]
               [ *discover-node *find-absolute-path]

               ;; need to fix generic to let me do these inside of arrays.

               (rel-path (Path.resolve (.join Path root path)))

               (seq (tokenize rel-path ))
               (node (find-value seq *tree)) 

               (fs this))

            (if node
                (.resolve Promise node)
                (.then (stat rel-path)
                       (*discover-node rel-path seq *tree fs))))

          (def-generic watch
              (path
               [root]
               (rel-path (.resolve Path root path))
               (fs this))

            (then (.find fs path [] rel-path) node
                  (on (.watch chokidar node.path) 'all (event-name changed-path stats)
                      (.then (.find fs changed-path [] ) (emit node event-name ))) node))

          (def-generic insert (path (rel-path (.resolve ))( type File ) (fs this))
            (catch (.find fs path)

              (let* ((seq (tokenize path))
                     (file-name (.pop seq)))

                (then-do (first (.reduce seq fill-sub-dir [(Promise.resolve) "./"]))
                         (.set-value ((create type) path fs)  )))))

          (def-generic set (path v ( type File ) (fs this))

            (then (.insert fs path type fs) node (.set-value node v))))





